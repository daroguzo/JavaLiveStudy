# 3주차
## 목표
자바가 제공하는 다양한 연산자를 학습하세요.

## 학습할 것  
+ 산술 연산자
+ 비트 연산자
+ 관계 연산자
+ 논리 연산자
+ instanceof
+ assignment(=) operator
+ 화살표(->) 연산자
+ 3항 연산자
+ 연산자 우선 순위
+ (optional) Java 13. switch 연산자

### 산술 연산자
> 산술 연산을 수행하는 연산자, 부호 연산자는 부호를 지정하는 연산자
>> 부호 연산자는 한 개의 피연산자를 요구하는 단항 연산자

|기호|기능|사용법|
|:--:|:--:|:--:|
|+|덧셈/부호|1+2, a+b, +1|
|-|뺄셈/부호|1-2, a-b, -1|
|*|곱셈|1*2, a*b|
|/|나눗셈|1/2, a/b|
|%|나머지|10%3, a%b|
- 두 피연산자 중 하나라도 double형이면 다른 하나도 double형으로 변환, 결과도 double
- 그렇지 않고 두 피연산자 중 하나라도 float형이면 다른 하나도 float형으로 변환, 결과도 float
- 그렇지 않고 두 피연산자 중 하나라도 long형이면 다른 하나도 long형으로 변환, 결과도 long
- 그렇지 않다면 두 피연산자를 모두 int형으로 변환, 결과도 int
__short + short = int__
__byte + byte = int__

### 비트 연산자
> 데이터를 비트 단위로 연산, 0, 1로 표현이 가능한 정수 타입만 비트연산이 가능, 기능에 따라 비트 이동연산자, 비트 논리 연산자로 구분

__비트 이동 연산자__
|연산식|설명|
|:--:|:--:|
|x << y|정수 x의 각 비트를 y만큼 왼쪽으로 이동(빈 자리는 0으로 채워짐)|
|x >> y|정수 x의 각 비트를 y만큼 오른쪽으로 이동(빈 자리는 정수 x의 최상위 부호 비트와 같은 값으로 채워짐)|
|x >>> y|정수 x의 각 비트를 y만큼 오른쪽으로 이동(빈자리는 0으로 채워짐)|
```Java
System.out.println(2 << 3);	// 16
System.out.println(16 >> 3);	// 2
System.out.println(-16 >> 3);	// -2
System.out.println(-16 >>> 3);	//536870910
```
__비트 논리 연산자__

|연산식|논리|설명|
|:--:|:--:|:--:|
|&|AND|두 비트 모두 1일 경우에만 1|
|\||OR|두 비트 중 하나만 1일 경우에만 1|
|^|XOR|두 비트 중 하나는 1이고 다른 하나가 0일 경우에만 1|
|~|NOT|비트 반전(보수)|

```Java
System.out.println(15 & 25);	// 9
System.out.println(15 | 25);	// 31
System.out.println(15 ^ 25);	// 22
System.out.println(~25);	// -26

```

### 관계 연산자
> 비교 연산자라고도 하며 부등호 연산, true or flase의 값인 boolean 자료형으로 반환

|연산자|가능|예|
|:--:|:--:|:--:|
|>|왼쪽 항이 크면 참, 아니면 거짓|a > 3|
|<|왼쪽 항이 작으면 참, 아니면 거짓|a < 3|
|>=|왼쪽 항이 오른쪽 항보다 크거나 같으면 참, 아니면 거짓|a >= 3|
|<=|왼쪽 항이 오른쪽 항보다 작거나 같으면 참, 아니면 거짓|a <= 3|
|==|두 개 항의 값이 같으면 참, 아니면 거짓|a == 3|
|!=|두 개 항의 값이 다르면 참, 아니면 거짓|a != 3|

### 논리 연산자
> 관계 연산자와 자주 같이 사용되며 true or flase의 값인 boolean 자료형으로 반환

|연산자|가능|예|
|:--:|:--:|:--:|
|&&|두 항이 모두 참인 경우에만 참, 아니면 거짓|(1<2) && (4>3)|
|\|\||두 항 중 하나의 항만 참이면 참, 두 항이 모두 거짓이면 거짓|(1>2) || (4>3)|
|!|참은 거짓으로, 거짓은 참으로 변경, 단항 연산자|!(1>2)|

### instanceof
> 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용, 형변환 가능 여부를 확인하며 연산의 결과는 boolean타입, 주로 상속 관계에서 부모 객체인지 자식 객체인지 확인하는 데에 사용

```Java
class Parent{}
class Child extends Parent{}

public class InstanceofTest{
	public static void main(String[] args) {
		Parent parent = new Parent();
		Child child = new Child();

		System.out.println(parent instanceof Parent);	// true
		System.out.println(child instanceof Parent);	// true
		System.out.println(parent instanceof Child);	// false
		System.out.println(child instanceof Child);	// true
	}
}
```
> 형변환이 불가능한(타입이 상위 클래스도 하위 클래스도 아닌) 경우에는 에러 발생

### assignment(=) operator
__대입 연산자__
> 변수에 값을 대입할 떄 사용하는 이항 연산자, 왼쪽의 피연산자에 오른쪽의 피연산자를 대입

|연산자|설명|
|:--:|:--:|
|=|왼쪽의 피연산자에 오른쪽의 피연산자를 대입|
|+=|왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 그 결괏값을 왼쪽의 피연산자에 대입|
|-=|왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 그 결괏값을 왼쪽의 피연산자에 대입|
|*=|왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 그 결괏값을 왼쪽의 피연산자에 대입|
|/=|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 결괏값을 왼쪽의 피연산자에 대입|
|%=|왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입|
|&=|왼쪽의 피연산자를 오른쪽의 피연산자와 비트 AND 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입|
|\|=|왼쪽의 피연산자를 오른쪽의 피연산자와 비트 OR 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입|
|^=|왼쪽의 피연산자를 오른쪽의 피연산자와 비트 XOR 연산한 후, 그 결괏값을 왼쪽의 피연산자에 대입|
|<<=|왼쪽의 피연산자를 오른쪽의 피연산자만큼 왼쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입|
|>>=|왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호를 유지하며 오른쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입|
|>>>=|왼쪽의 피연산자를 오른쪽의 피연산자만큼 부호에 상관없이 오른쪽 시프트한 후, 그 결괏값을 왼쪽의 피연산자에 대입함.|

### 화살표(->) 연산자
> 단 하나의 객체만을 생성할 수 있는 클래스(익명 클래스), 람다 표현식을 작성하기 위한 연산자
>> (매개 변수 목록) -> {함수 몸체}

~~~Java
new Thread(new Runnable(){
	public void run() {
		System.out.println("전통적인 방식의 일회용 스레드 생성");
	}
}).start();

new Thread(()->{
	System.out.println("람다 표현식을 사용한 일회용 스레드 생성");
}).start();
~~~

### 3항 연산자
> (조건문) ? 참 : 거짓;

```java
// if else
int a;

if (3 > 2)
	a = 2;
else
	a = 1;

// 3항 연산자
int b = (3 > 2) ? 2 : 1;
```

### 연산자 우선 순위
|우선순위|연산자|내용|
|:--:|:--:|:--:|
|1|(), []|괄호 / 대괄호|
|2|!, ~, ++, --|부정 / 증감 연산자|
|3|*, /, %|곱셈 / 나눗셈 연산자|
|4|+, -|덧셈 / 뺄셈 연산자|
|5|<<, >>, >>>|비트 단위의 쉬프트 연산자|
|6|<, <=, >, >=|관계 연산자|
|7|==, !=||
|8|&|비트 단위의 논리 연산자|
|9|^||
|10|\|||
|11|&&|논리곱 연산자|
|12|\|\||논리합 연산자|
|13|?:|조건 연산자|
|14|=, +=, -=, /=, %=, <<=, >>=, &=, ^=, ~=|대입 / 할당 연산자|

### (optional) Java 13. switch 연산자
__switch 문__
- 다수의 case, break 존재
- break가 없다면 다음 분기로
- return 존재 불가

__switch 연산자__
- break 사용하지 않아도 됨
- yield 존재
- return 값 존재 가능
- case에 화살표 연산자 사용 가능
> swith의 반환값이 따로 필요하지 않거나 case가 switch로 들어오는 모든 인자를 커버하는 경우 default 불필요, 그렇지 않은 경우는 default -> code 작성
>> yield 키워드를 사용해서 반환

```java
public String today(String day){

	String result = switch(day) {
		case MON, TUE, WED, THUR, FRI -> day = "Weekday"
		case SAT, SUN -> {
			yield day = "Weekend";
		}
	};
	return result;
}
```